# Mu frontend skeleton application

За основу взят [Create React App](https://github.com/facebook/create-react-app) на 17 react и 4 typescript.
К нему добавлен ant.design 4.8

## Доступные команды

Запуск проекта локально

### `yarn start`

Запускает проект [http://localhost:3000](http://localhost:3000) в development mode.

Для запуска тестов

### `yarn test`

Для продакшен сборки

### `yarn build`

Docker сборка

`docker build -t mu-frontend:prod .`

`docker run -p 8080:80 -t mu-frontend:prod`

### Логика работы

1. Перенос элемента из базы на фронт

Поскольку мы должны отражать реальное состояние дерева на фронте, но показывать только непосредственную связь нод,
дальние связи мы должны так же хранить в памяти, чтобы удалении элементов удалять (помечать на удаление)
другие элементы на странице, не связанные с удаляемой нодой непосредственной связью.

При переносе элемента из базы на фронт мы вынуждены перестраивать элементы на странице,
чтобы отразить их непосредственные связи с новым элементом, если таковые существуют.

2. Удаление элемента

Мы помечаем элемент на удаление и должны пометить так же те элементы, которые являются для него дочерними,
как непосредственно связанные с текущим, так и дальние дочерние элементы.
Для этого мы должны хранить в каждом элементе список идентификаторов
всех дочерних элементов удаляемой ноды (и дальних тоже), присутствующих на фронте.

3. Синхронизация базы и фронта
Может происходить только дважды. При добавлении элемента с базы на фронт и при нажатии кнопки Apply на фронте.
Если мы на фронте удалили элемент, а его дальний (или нет) дочерний элемент
никогда не присутствовал на фронте, но мы добавляем его на фронт, мы должны сразу пометить его на удаление.

```В условии задачи нет запрета на перенос на фронт удаленных элементов. 
Мы только не можем их редактировать.```

```Мы применяем изменения в базу только по кнопке Apply. До нажатия этой кнопки будем считать,
что все наши изменения на фронте - черновик, который может быть и не сохранен.```

## Алгоритм

Для уменьшения глубины поиска, мы храним в каждом элементе базы его расстояние от корня - длину.
Так же, в каждом элементе мы храним массив айдишников на его детей и айди родителя.

При переносе нового элемента из базы на фронт мы должны проверить, не являются ли уже перенесенные
элементы его дочерними или родительскими.

Если длина у элемента на фронте больше длины переносимого элемента, значит он может быть его дочерним,
если меньше - значит может быть его родителем. Если равна - значит они на одном уровне, эту ситуацию
мы не обрабатываем.

